JavaScript
1. Core Concepts
Closures: Functions retaining access to their lexical scope, even when the function is executed outside that scope.
Promises & Async/Await: Managing asynchronous operations with .then and .catch, using async and await for cleaner syntax.
Event Loop & Callbacks: Understand the event loop, call stack, and how JavaScript handles asynchronous code.
Hoisting: Variable and function declarations are "hoisted" to the top of their scope.
Prototype Chain: JavaScript’s inheritance model, where objects inherit properties and methods from their prototype.
Modules (ES6): Import/export syntax for modular JavaScript.
2. Advanced Topics
Functional Programming: Concepts like immutability, pure functions, and higher-order functions (map, filter, reduce).
Error Handling: Try-catch, handling errors with Promises.
DOM Manipulation: Adding, removing, or changing DOM elements.
Data Structures: Arrays, Objects, Maps, Sets, and their methods.
Performance Optimization: Debouncing, throttling, and efficient DOM updating.
CSS
1. CSS Basics
Selectors: ID, class, attribute, pseudo-selectors (:hover, :nth-child, etc.).
Box Model: margin, padding, border, and content.
Positioning: static, relative, absolute, fixed, sticky.
Display & Flexbox: display: flex;, alignment, spacing, and grid.
2. Advanced Topics
CSS Grid: Setting rows and columns, grid areas, and layout structure.
Responsive Design: Media queries, responsive units (%, vw, vh).
Animations: Keyframes, transitions, and animation properties.
CSS Preprocessors: Sass, SCSS, and the ability to nest CSS and use variables.
CSS in JS: Styled-components, emotion, and CSS modules (especially relevant for React).
React
1. Core Concepts
JSX: Syntax extension for writing HTML within JavaScript.
State & Props: Managing component state and passing data via props.
Lifecycle Methods: Mounting, updating, and unmounting phases (class components) or useEffect for functional components.
Event Handling: Binding events in JSX, passing parameters in event handlers.
Conditional Rendering: Using ternary operators, && conditions.
Forms: Controlled vs. uncontrolled components, handling form state and submission.
2. Advanced React
Hooks: useState, useEffect, useContext, useReducer, and custom hooks.
Context API: Managing global state without props drilling.
Higher-Order Components (HOCs): Wrapping a component to extend its functionality.
React Router: Dynamic routing, Link, NavLink, useParams, useHistory.
Error Boundaries: Handling component errors gracefully.
Optimization: React.memo, useMemo, useCallback to reduce unnecessary re-renders.
Flutter (Web)
1. Core Concepts
Widgets: Stateless vs. Stateful, understanding the widget tree.
Layouts: Using Row, Column, Stack, and Container.
State Management: Using setState, provider pattern, and other state management solutions like Riverpod.
Routing & Navigation: Navigator and Route, handling routes and transitions.
2. Advanced Topics
Rendering Performance: Optimizing widget rebuilding, using keys effectively.
Forms & Validation: Using Form and TextFormField, managing form state.
Animations: Built-in animations, AnimatedContainer, Hero, Tween.
Flutter Web Specifics: Responsiveness in web, media queries for different devices.
Canonical-Specific Tips
Ubuntu and Linux Familiarity: Canonical develops Ubuntu, so familiarity with the Linux OS and terminal commands is helpful.
Open Source Mindset: Canonical is heavily involved in open-source software. Be prepared to discuss any open-source contributions or your experience working in open-source projects.
CI/CD and DevOps: Understanding of deployment pipelines, Git, Docker, and other CI/CD tools could be advantageous.
Collaboration & Remote Work: Canonical is a remote-first company. Experience with remote work tools and asynchronous communication might be beneficial.
Sample Interview Questions
JavaScript: Explain how closures work. Can you give an example where they’re particularly useful?
CSS: How would you create a responsive grid layout using CSS Flexbox or Grid?
React: What are React hooks, and why did they replace class-based lifecycle methods? Explain useEffect.
Flutter: How would you optimize performance in a large, complex widget tree? What is the difference between setState and a provider?
